#include "functions.h"
#include "test.h"
int main()
{
    printf("*****************Task 1*******************\n");
    // Задание 1 (творческое). swap
    // Напишите функцию swap(int *i, int *j), которая меняет значения двух ячеек местами.
    // Напишите как можно больше тестов для этой функции (не меньше 10)
    // На звёздочку: используйте фреймворк наподобие MinUnit https://github.com/siu/minunit
    run_tests();


    // Задание 2. Указатели на массивы в качестве аргументов.
    // Напишите два варианта функции поиска минимального элемента
    // 2a. во встроенном двухмерном массиве
    // 2b. в динамическом двухмерном массиве (обе размерности вычисляются)
    printf("*****************Task 2*******************\n");
    int arr[ROWS][COLS] = {{1, 2, 3},{12, 11, 10},{0, 14, 16}};
    printf("Minimum value in an array: %d \n\n", MyMin(arr, ROWS, COLS));


    srand(time(NULL));
    int rows = 3; 
    int cols = 3;
    
    int** d_arr = malloc(rows * sizeof(int*)); 
    for (int i = 0; i < rows; i++) 
        d_arr[i] = malloc(cols * sizeof(int));
    
    for (int i = 0; i < rows; i++)
        for (int j = 0; j < cols; j++)
            d_arr[i][j] = rand() % 100; 
    PrintArr(d_arr, rows, cols); 
    printf("Minimum value in an dynamic array: %d\n\n", DynamicMyMin(d_arr, rows, cols)); 
    

    for (int i = 0; i < rows; i++)
        free(d_arr[i]);
    free(d_arr);

    // Например:
    // int ar[N][M] = {список значений};
    // int res = myMin(ar, ... наверняка понадобится передать ещё какие-нибудь данные);
    
    
    // Задание 3. Напишите функцию сравнения двух строк - myStrCmp():
    // Функция должна принимать два указателя на сравниваемые
    // строки (возможно, понадобится сказать компилятору, что функция
    // не имеет права модифицировать содержимое строк)
    // Функция должна возвращать отрицательное значение, если
    // первая строка лексиграфически меньше второй, 0 - если они равны
    // и положительное значение, если первая строка больше второй.
    // Вспомните, что признаком конца строки является нулевой байт.
    printf("*****************Task 3*******************\n");
    const char* s1 = "apple"; 
    const char* s2 = "iphone"; 
    int result = myStrCmp(s1, s2);

    if (result < 0)
        printf("'%s' < '%s'\n", s1, s2);
    else if (result > 0)
        printf("'%s' > '%s'\n", s1, s2);
    else
        printf("'%s' == '%s'\n", s1, s2);




    // Задание 4. Создайте одномерный динамический массив, заполните его значениями.
    // Напишите функцию, которая добавляет в массив новое значение только при условии,
    // что такого значения в массиве еще нет. Подсказка: при этом размер
    // массива должен увеличиться!
    // Для проверки напишите функцию, которая выводит значения всех элементов на экран
    
    printf("\n*****************Task 4*******************\n");

    int size = 5; 
    int n = 10; 
    int* d_ar = malloc((size) * sizeof(int));

    for (int i = 0; i < size; i++) 
    {
        d_ar[i] = rand() % 20; 
    }
    
    printf("Size array: %d\nRequired number: %d\n", size, n);
    printAr(d_ar, size);
    addArr(&d_ar, &size, n); 
    printAr(d_ar, size); 

    free(d_ar);


    printf("\n*****************Task 5*******************\n");

    // Задание 5. Рекурсивные функции.
    // 5a. Напишите рекурсивную функцию вычисления суммы первых N натуральных чисел
    int ns = 8; 
    printf("Sum: %d\n", summN(ns));

    // 5б. Напишите рекурсивную функцию для вычисления N-го числа Фибоначчи
    printf("Fibonschi: %d\n", fib(ns));

    // Задание 6а. Функции с переменным числом параметров.
    // Напишите функцию varArgs, не использующую макросы,
    // которая принимает переменное число аргументов (см. подсказку внизу кода задания)
    // типа int и выводит на печать число принятых параметров и их значения.
    // Признаком конца списка параметров является нулевое значение.
    printf("\n*****************Task 6a*******************\n");

    int args[] = { 5, 11, 4, 7, -1 };

    varArgs(args[0], 0);
    varArgs(args[0], args[1], 0);
    varArgs(args[0], args[1], args[2], args[3], args[4], 0);
    
   //я предпологал что аргументы лежат в памяти подряд как массив, но вывод показывает обратное
   //поэтому чтобы получать гарантированный результат мы используем функции библиотеки stdarg.h
       
    // Задание 6б. Модифицируйте функцию 5а с помощью макросов
    //  va_start, va_arg, va_end
    printf("\n*****************Task 6b*******************\n");
    varArgsMod(args[0], 0);
    varArgsMod(args[0], args[1], 0);
    varArgsMod(args[0], args[1], args[2], args[3], args[4], 0);



    // Задание 7. Возвращение адреса.
    // Напишите функцию, которая находит минимальное значение в массиве,
    // таким образом, чтобы ее вызов можно было использовать слева от знака
    // равенства: *myMin(параметры) = 0;
    printf("\n*****************Task 7*******************\n");
    int arrm[] = { 5, 11, 4, 7, -1 };
    size = sizeof(arrm) / sizeof(arrm[0]);
    *myMin(arrm, size) = 0;
    printAr(arrm, size);

    printf("\n*****************Task 8*******************\n");
   

    unsigned week;
    enum DayType day;
    int y = 2024, m = 12, d = 15;
    int res = transfrom(y, m, d, &week, &day);
    printf("%u-%02u-%02u → week %u, day %d\n", y, m, d, week, day);
    return 0;
}



