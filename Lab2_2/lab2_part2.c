#include <stdio.h>
#include <stdlib.h>



int main()
{
    // Задание 5. Арифметика указателей. Операция разыменования указателя.
    // Выполняя задание, следите за изменением значений
    // указателей и значений объектов, на которые они указывают.
    // Интерпретируте наблюдаемые результаты
    {
        long* p = 123;
        long* q = p + 5;
        char dist = q - p;


        int nAr[2] = {1, 3}; //объявляем массив
        int *pn = &nAr[0]; //объявляем указатель на элемент массива *pn = 1
        

        (*pn)++; //прибавляем единицу к элементу массива адрес которого в указателе pn => *pn = 2; nAr = {2, 3}
        pn++;  //прибавляем единицу к указателю, теперь он указывает на 1 элемент в массиве nAr[1] => *pn = 3


        char cAr[] = {'A', 'B', 'C', 'D'}; //объявляем массив
        char *pc = &cAr[0]; //объявляем указатель на элемент масива *pc = 65 'A'

        (*pc) = (*(pc + 2)) + 5; // прибавляем 5 к элементу массива адрес которого в указателе pc => *pc = 70 'F'; cAr[] = {'F', 'B', 'C', 'D'}
        pc[0] = pc[2] + 5; 


        pc = pc + 3; //прибавляем 3 к указателю, теперь он указывает на cAr[3] => *pc = 68 'D' 
        

        double dAr[3] = {1.0, 2.0}; // объявляем массив 
        double *pd1 = &dAr[0]; // объявляем указатель *pd1 и присваиваем ему адрес элемента массива dAr[0]
        double *pd2 = pd1; // объявляем указатель *pd2 и вносим в него значение переменной pd1 (адресс dAr[0]) 
        (*pd2) += 2; //прибавляем 2 к переменной адрес которой указан в pd2 те адресс в pd1 те к dAr[0] от сюда *pd1 = 3.0; *pd2 = 3.0; dAr[0] = 3.0  
        pd2 += 2; // прибавляем 2 к адресу в указателе pd2, теперь он указывает на dAr[2] и будет равн значению этого элемента, оалные знчея не меняются  
        

        // Объясните результат выполнения операции
        // вычитания двух указателей
        pd1 = &dAr[0];
        pd2 = &dAr[1];
        int nNumber = pd2 - pd1; // как мы разобрали выше адреса одного массива обозначаются по порядку и адресс 0-го элемента массива меньше адреса 1-го элемента на 1 
        // от сюда результат выражения  pd2 - pd1 = 1 
    }

    // Задание 6. Void-указатель.
    // Выполняя задание, посмотрите, какие значения присваиваются
    // void-указателю. Обратите внимание: средствами отладчика
    // нельзя посмотреть значения, на которые "указывает"
    // void-указатель
    {
        void *pVoid;
        int nObject = 5;
        char cObject = 'A';
        int *pInt = &nObject;
        pVoid = &nObject;
        pVoid = &cObject;
        pVoid = pInt;
        pInt = pVoid; 
        pInt = pInt; 
        // Подумайте, что нужно сделать, чтобы выражение стало корректным
        // pInt = pVoid;
    }

    // Задание 7. Модификатор const. В каждом из заданий
    // объявите указатель требуемого вида
    {
        // 7a. Указатель является константой. 
        int a = 5; 
        int *const cIna = &a;
        int *const cina2 = &cIna;
         

         
        // 7б. Указываемое значение является константой.
        const int b = 5; 
        const int *cInb = &b;
        

        // 7в. И указатель, и указываемое значение являются константами.
        int c = 10; 
        const int *const cInc = &c;

        const int* const* cInd = &cInc; 

        

        
    }

    // Задание 8. Динамическая память
    // Напишите код, который предлагает пользователю ввести число 'n' с клавиатуры
    // после этого пользователю предлагается ввести ещё 'n' чисел (через пробел в одной строке либо последовательно, как удобнее)
    // результат нужно записать в массив и вывести в обратном порядке на экран через пробел
    // Пример входа:
    // 5
    // 1 4 3
    // Вывод: 3 4 1
    
    int n; // объявляем переменную для размера массива
    scanf_s("%d", &n); // вводим значение переменной 
    int* nInt = (int*)calloc(n, sizeof(int)); //объявляем указатель и присваиваем ему адрес которй возвращает функция malloc, которая в свою очередь выделяет область памяти 
    //учитывая количество элементов массива (n) и тип данных int
    for (int i = 0; i < n; i++) { // вводим значения элементов массива 
        scanf_s("%d", &nInt[i]);
    }
    for (int i = n-1; i >= 0; i--) { // выводим в обратном порядке
        printf("%d ", nInt[i]);
    }
    free(nInt);
}
