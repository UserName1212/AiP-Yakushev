/*************************************************************
    Практическое занятие №2. Побитовые операторы.
                            Директивы препроцессора.
                            Указатели.
*************************************************************/

#define _USE_MATH_DEFINES
#include <math.h>
#include <stdio.h>
/*void f(int y, char n) {
    int bits = sizeof(y) * 8; 
    for(int i = bits -1; i>0; i--)
    {
        unsigned int bit = (y >> i) & 1; 
        if (bit==1 && n==1){ 
            for (int j = i; j >= i; j--) {
                unsigned int nbit = (y >> j) & 1; 
                printf("%d", nbit);
            }

    */
int main()
{
    // Задание 1. Побитовая арифметика (and, or, xor, not), сдвиги.
    // 1.1
    {
        int y; // задайте значение y явно или через scanf
        printf("enter y: ");
        scanf_s("%i", &y); 
        int bits = sizeof(y) * 8; // количество байт * 8 = к-во бит
        for (int i = bits - 1 ; i > 0; i--) {
            unsigned int bit = (y >> i) & 1; // смотрим на значение бита и вносим его в переменную bit 
            if (bit == 1) { //  условие для записи тоолько значимых битов 
                for (int j = i; j >= 0; j--) { 
                    unsigned int nbit = (y >> j) & 1; 
                    printf("%u", nbit);
                }  
                break;
            }
            
         }
        printf("\n\n");
        // С помощью побитовых операторов и операторов сдвига выведите значение "y"
        // в консоль в двоичном виде, например:
        // если y==9, то
        //  а) 0 0 0 0 ...   0 0 1 0 0 1 (количество двоичных цифр зависит от платформы)

        // б) пропустите незначащие нули -  1 0 0 1

    }

    // 1.2
    {
        int y;
        printf("enter y: ");
        scanf_s("%i", &y);
        printf("1.2: ");
        char k = 0;
        int bits = sizeof(y) * 8; // количество байт * 8 = к-во бит
        for (int i = bits - 1; i >= 0; i--) {
            unsigned int bit = (y >> i) & 1;
            if(bit == 0 && k == 0) {
                printf("%u", bit);
            }else if(bit == 1 && k == 1) {
                printf("%u", bit);
            }
            if (i == 0 && k == 0) {
                k = 1;
                i = bits - 1;
            }
            
        }
        printf("\n\n");
        int x = 8; 
        int z = x >> 1; 
        printf("z = %d\n", z); 
        //"Сдвиньте" все единицы переменной вправо, например:
        // было:   0100 1111 0000 0000 0110 1111 0000 0010
        // стало:  0000 0000 0000 0000 0000 1111 1111 1111
        // Реализовать задачу посредством одного цикла

    }

    // 1.3 Какие операции следует применить к заданному ниже операнду sNum для
    // того, чтобы переменная sRes приняла требуемое значение?
    // Замечание 1: значения подобраны таким образом, что в каждом случае достаточно
    // использовать один оператор (и при необходимости маску)
    // Замечание 2: посредством оператора xor (подобрав соответствующую маску)
    // можно получить любое значение => этот оператор предполагается использовать
    // в том случае, когда все остальные уже "не спасают"

    {
        short sNum = 0x8008; // 1000 0000 0000 1000
        short sRes;

        // 0x7ff7  0111 1111 1111 0111
        sRes = ~sNum; 
        printf("%x\n", sRes);

        // 0x8ff8 1000 1111 1111 1000
        sRes = sNum | 0x0ff0; 
        printf("%x\n", sRes);

        // 0x0008 0000 0000 0000 1000
        sRes = sNum & 0x0008;
        printf("%x\n", sRes);

        // 0x7f08 0111 1111 0000 1000
        sRes = sNum ^ 0xff00;
        printf("%x\n", sRes);

        // 0xf001
        sRes = sNum >> 3; 
        printf("%x\n", sRes);

        // 0x0010
        sRes = sNum << 1; 
        printf("%x\n\n", sRes);

        short s = 0x41A7; 
        short sr; 

        // 0x4187
        sr = s & 0xFFDF; 
        printf("%x\n", sr);

        // 0x4DB7
        sr = s | 0x0DB0;
        printf("%x\n", sr);

        // 0x0778
        sr = s ^ 0x46DF; 
        printf("%x\n", sr);
    }

    // ********************************************************
    // Задание 2. Директивы препроцессора

    // 2.1. В заголовочном файле <math.h> определены часто используемые математические
    // константы, например M_PI. Воспользуйтесь этой константой для
    // вычисления длины окружности
    int R = 12; 
    double l; 
    l = 2 * M_PI * R; 


    // 2.2.Макросы с параметрами.
    // 2.2.1 Напишите свою макроподстановку LENGTH которая вычисляет длину окружности.
    //  протестируйте написанный макрос для следующих ситуаций:
#define LENGTH(R) (2 * M_PI * R)
    {
        
        float l1 = LENGTH(1 + 2); // должно быть 18.8495... 
        float l2 = 1 / LENGTH(2); // должно быть 0.07957...
        l2 = l2;
    }

    // 2.2.2 определите макрос MAX(A, B)  для вычисления большего
    // значения из двух.
#define MAX(x,y) ((x) > (y) ? (x) : (y)) 
    
        int i = 10, j = 12, k;
        k = MAX(i, j);
        k = MAX(j, i) * 2;
        k = MAX(j, i+3);

        k = k;


        // 2.2.3 определите макрос EXCHANGE(X, Y)  для перестановки
        // двух объектов типа int в памяти местами. Проверьте для приведенного
        // фрагмента. Подумайте, что будет делать макроподстановка, если
        // переставляемые значения разного типа???
#define EXCHANGE(x,y)  {\
        int z = (x);      \
        (x) = (y);        \
        (y) = (z);        \
        }
    
        int x1 = 1;
        float y1 = 2;
        EXCHANGE(x1,y1);

        int x2=100, y2=-100;
        EXCHANGE(x2,y2);

    

    
    //2.3. Директивы условной трансляции
    //Выполняя следующий фрагмент, посмотрите, какое
    //значение принимает переменная iNN. Что нужно сделать
    //для того, чтобы результат был равен 0? 1? 2?

int iNN; // опеределение констант 
//#define MMM
#define NNN
#if defined NNN && defined MMM //должны быть определены константы NNN и MMM 
    iNN = 0;
#elif defined MMM // должна быть определена константа MMM
    iNN = 1;
#elif defined NNN // должна быть определена константа NNN
    iNN = 2;
#else // если нет определенных констант 
    iNN = -1;
    iNN = iNN;
#endif


    // ********************************************************
    // Задание 3. Заголовочные файлы. Директива #include
    // 3.1.Создайте и подключите к проекту два заголовочных файла 1.h и 2.h
    // В каждом заголовочном файле объявите перечисление с одинаковыми именами
    // констант, но сопоставьте именованным константам разные значения, например:
    // 1.h - enum MyEnum{My1, My2, My3};  . 2.h - enum MyEnum{My1=5, My2, My3};
    // С помощью директив условной трансляции в DEBUG-версии пользуйтесь значениями
    // констант из 1.h, а в RELEASE-версии значениями констант из 2.h

#ifdef _DEBUG
    #include "1.h"
#else
    #include "2.h"
#endif 
    
    enum MyEnum value = My2;

    printf("\nValue My2 = %d\n", value);

    return 0;

    // ********************************************************
    // Задание 4. Указатели
    // Объявите объекты разных типов и проинициализируйте их.
    // Объявите указатели соответствующих типов и проинициализируйте их
    // адресами заданных объектов.
    // Выполняя задание, с помощью отладчика посмотрите, какие значения
    // будут присвоены переменным-указателям и на что эти указатели
    // "указывают"
#include "1.h"

    int a = 2; 
    char b = 11;
    double c = 3.14;
    short n = 0x0001;
    
    int* p_a = &a; 
    char* p_b = &b;
    double* p_c = &c; 
    short* p_n = &n;

    *p_a = *p_a + 1; 
    (*p_a)++;
    int h = *p_a;
    

   

}
